I"ùu<h1 id="normalizing-text-with-regex-groups-in-python">Normalizing Text with Regex Groups in Python</h1>

<p>In this post we‚Äôre going to look at how regex groups can help clean messy text data, and in this specific case by normalizing product numbers.  The data comes from <a href="[http://www.sourcinginnovation.com/glossary/RFX.php">RFX</a> instrument bids.  The challenge here is that while a company may have a concrete way of idenitfy their own products, these product IDs are commonly mistyped when customers request product. We‚Äôll see to fix common mistakes by a regular expression that matches all the erroneous forms and uses groups to pull out specific parts from the regex.</p>

<h3 id="basic-yamaha-product-id">Basic Yamaha Product ID</h3>

<p><a href="https://www.yamaha.com/en/">Yamaha</a>, the world‚Äôs largest instrument manufactuer, has designed a Product ID system which encodes descriptive information about the product.  Identifing the inherent morphology allows someone to know which instrument it is, but also any special customizations or features it may have. Luckily for us, we don‚Äôt need to know that.</p>

<p>Let‚Äôs use the Yamaha Tuba, <a href="https://usa.yamaha.com/products/musical_instruments/winds/tubas/ybb-105/specs.html#product-tabs">YBB-105WC</a>, as our base example. For our purposes the pattern of the Yamaha wind instrument is:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Brand</th>
      <th style="text-align: left">Instrument</th>
      <th style="text-align: left">Hyphen</th>
      <th style="text-align: left">Series</th>
      <th style="text-align: left">Feates</th>
      <th style="text-align: left">Mark/Iteration*</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Y</td>
      <td style="text-align: left">BB</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">105</td>
      <td style="text-align: left">WC</td>
      <td style="text-align: left">‚àÖ</td>
    </tr>
    <tr>
      <td style="text-align: left">Yamaha</td>
      <td style="text-align: left">Tuba</td>
      <td style="text-align: left">delimiter</td>
      <td style="text-align: left">100 Series</td>
      <td style="text-align: left">With Case</td>
      <td style="text-align: left">Product Iteration</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>The Mark or iteration is usally written with Roman Numerals, such as YAS-200AD<strong>II</strong>. No roman numerals means the product is the first iteration!</p>
</blockquote>

<p>Since we don‚Äôt need to pull out this level of detail from IDs in our example, we‚Äôll reduce this template even further.</p>

<p>Interestingly enough, this system was so successful that other companies noticed and started following a similar approach. Note the similarity between the Jupiter Tuba <a href="http://jupitermusic.com/us/products/brass/tubas/">JTU1110</a> and Eastman Tuba <a href="https://www.eastmanwinds.com/ebb234">EBB234</a>. Any guesses on what the first letter stands for?</p>

<h3 id="examening-the-typos">Examening the typos</h3>

<p>Let‚Äôs look at the typos we‚Äôll be trying to normalize. Let‚Äôs look at the Yamaha Alto Sax <a href="https://usa.yamaha.com/products/musical_instruments/winds/saxophones/yas-200adii/index.html">YAS-200ADII</a>. This Product ID might be written a variety of ways such as:</p>

<ul>
  <li>yas200adii</li>
  <li>yas 200</li>
  <li>YAS 200AD</li>
  <li>yas - 200</li>
  <li>yas - 200ADII</li>
  <li>YAS200AD II</li>
</ul>

<p>And the list goes on.</p>

<h3 id="goal">Goal</h3>

<p>Our goal is to get all Yamaha product IDs into a canonical form reducing messy data and making them easier to work with.  We will not be correcting typos or incomplete IDs such as <strong>T</strong>FL-222 instead of YFL-222 or YAS-2<strong>80</strong> in place of YAS-200<strong>ADII</strong>. Let‚Äôs operationalize our normalized form. Ideally:</p>

<ul>
  <li>ALL CAPS</li>
  <li>No spaces</li>
  <li>Has delininating hyphen</li>
  <li>Mark (as in ‚Äòmark ‚Ö†‚Äô or ‚Äòmark ‚Ö°‚Äô) is optional, but present if available</li>
</ul>

<p>This would mean that the previous list of error examples will all be canonicalized as YAS-200II and whichever mark such as ‚ÄòII‚Äô or otherwise will only be included if it‚Äôs already listed. It‚Äôs absense will only be considered a typo.</p>

<h3 id="libraries">Libraries</h3>

<p>We‚Äôll be using the <a href="https://docs.python.org/3.8/library/re.html">re library</a> for regular expressions.
We‚Äôll also be using the <code class="highlighter-rouge">Counter</code> object from <a href="https://docs.python.org/3.1/library/collections.html#collections.Counter">Collections</a> to manipulate the data easier and generate some statistics.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
</code></pre></div></div>

<h3 id="python-regex-groups">Python Regex Groups</h3>

<p>Part of the <code class="highlighter-rouge">re</code> library, groups allow you select and extract certain subpatterns of a regular expression. So we‚Äôll pull out the germane parts of an ID and and normalize them to our standard form.</p>

<p>The syntax of a group is simple:  (?P&lt;group_name&gt;‚Ä¶) where <strong>group_name</strong> is a name we choose for this group and the elipsis is the regex for the group.</p>

<p>For example, let‚Äôs separate ‚ÄòY‚Äô from ‚ÄòFL‚Äô in ‚ÄòYFL‚Äô. We assign ‚ÄòFYL‚Äô to <code class="highlighter-rouge">string</code> and for our pattern we make two groups in one regular expression. One named <code class="highlighter-rouge">yamaha</code> and the other <code class="highlighter-rouge">instrument</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="o">=</span> <span class="s">'YFL'</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="s">'(?P&lt;yamaha&gt;y)(?P&lt;instrument&gt;[a-z]+)'</span>
<span class="n">ex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
</code></pre></div></div>

<p>We can examen specific groups by using the <code class="highlighter-rouge">group()</code> method and pass it the group name as a string.  Please note that <code class="highlighter-rouge">re.match()</code> was passed the <code class="highlighter-rouge">re.IGNORECASE</code> flag so that the regex is case insensitive.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'yamaha'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'instrument'</span><span class="p">))</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Y
FL
</code></pre></div></div>

<p>Simple enough, now for something more complex. Let‚Äôs designed a regex that‚Äôll encompass the various iterations of Yamaha product ID. We‚Äôre going to break it into 3 groups: <code class="highlighter-rouge">yamaha_instrument</code>, <code class="highlighter-rouge">series</code>, and <code class="highlighter-rouge">mark</code>.</p>

<p>Note that the first group <code class="highlighter-rouge">yamaha_instrument</code> we‚Äôll be conflating both the brand ‚ÄòYamaha‚Äô and ‚Äòinstrument since we don‚Äôt have a practical reason to distinguish them. <code class="highlighter-rouge">Series</code> will also conflate any [numeric]+[alpha]* pattern after the delimiter (that is hyphen in our canonical form). The group, <code class="highlighter-rouge">mark</code>, only will come to play if the the mark is separated by a space from the <code class="highlighter-rouge">series</code>.</p>

<p>We‚Äôll first use the regex to extract all the Yamaha IDs from the data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="n">yamaha_pattern</span> <span class="o">=</span> <span class="s">r'\b(?P&lt;yamaha_instrument&gt;Y[A-Z]{2})[\s-]*(?P&lt;series&gt;[0-9]+[A-Z]*)\s*(?P&lt;mark&gt;I*)\b'</span>

<span class="k">with</span> <span class="n">codecs</span><span class="o">.</span><span class="nb">open</span><span class="p">(</span><span class="s">'yamaha_skus.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'utf8'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">products</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
    

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'Total Number of Yamaha IDs: {len(products)}'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'Sample of Product IDs: {products[:4]}'</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Total Number of Yamaha IDs: 596
Sample of Product IDs: ['YAC1607', 'YAS - 26', 'YAS - 480', 'YAS - 480SY']
</code></pre></div></div>

<p>The Table below describes this regex chunch by chunck. For a more thorough regex review, consult the <a href="https://docs.python.org/3.8/library/re.html">re documentation</a>. Notice</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Regex component</th>
      <th style="text-align: left">Explaination</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">\b</td>
      <td style="text-align: left">word boundry</td>
    </tr>
    <tr>
      <td style="text-align: left">(?P&lt;yamaha_instrument&gt;Y[A-Z]{2})</td>
      <td style="text-align: left">a group name <strong>yamaha_instrument</strong> that consists of a y followed by two other alphabetic characters</td>
    </tr>
    <tr>
      <td style="text-align: left">[\s-]*</td>
      <td style="text-align: left">zero or more spaces or hyphens in any order</td>
    </tr>
    <tr>
      <td style="text-align: left">(?P&lt;series&gt;[0-9]+[A-Z]*)</td>
      <td style="text-align: left">a group named <strong>series</strong> which can consist one or more numbers followed by zero or more alphabetic characters</td>
    </tr>
    <tr>
      <td style="text-align: left">\s*</td>
      <td style="text-align: left">zero or more spaces</td>
    </tr>
    <tr>
      <td style="text-align: left">(?P&lt;mark&gt;I*)</td>
      <td style="text-align: left">named group called <strong>mark</strong> which consists of zero or more i‚Äôs</td>
    </tr>
    <tr>
      <td style="text-align: left">\b‚Äô</td>
      <td style="text-align: left">word boundry</td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">products</code> is a list of various Yamaha product IDs.  The data comes from RFX data which can be found <a href="https://github.com/apocop/apocop.github.io/blob/master/_jupyter/2019-11-13-python-group-regex/yamaha_skus.txt">here</a>.</p>

<p>Now that we have a regex that will separate all these product IDs, we‚Äôll create a function that takes a product id and normalizes it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">normalize_yamaha_product_id</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="s">'Return idealized form of Yamaha product ID'</span>
    <span class="n">product_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    
    <span class="c1"># The three groups.
</span>    <span class="n">yamaha_instrument</span> <span class="o">=</span> <span class="n">product_id</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'yamaha_instrument'</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">series</span> <span class="o">=</span> <span class="n">product_id</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'series'</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">mark</span> <span class="o">=</span> <span class="n">product_id</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">'mark'</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    
    <span class="c1"># Put extracted groups into final normalized form.
</span>    <span class="k">return</span> <span class="n">f</span><span class="s">'{ yamaha_instrument}-{series}{mark}'</span>
</code></pre></div></div>

<p>Let‚Äôs test our function and make sure it preforms well. With these basic tests it seems to work well. Be sure to mess around with your own test case, and try to make it fail.  What happens, for example, if you have ‚Äòyas - 200 ADII‚Äô?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Test: (input, correct_ouput)
</span><span class="n">test</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s">'yas200adii'</span><span class="p">,</span> <span class="s">'YAS-200ADII'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'yas 200'</span><span class="p">,</span> <span class="s">'YAS-200'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'yas 200AD'</span><span class="p">,</span> <span class="s">'YAS-200AD'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'yas - 200ADII'</span><span class="p">,</span> <span class="s">'YAS-200ADII'</span><span class="p">),</span>
    <span class="p">(</span><span class="s">'YAS200AD II'</span><span class="p">,</span> <span class="s">'YAS-200ADII'</span><span class="p">)</span>
<span class="p">]</span>

<span class="k">for</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">test</span><span class="p">:</span>
    <span class="n">test_case</span> <span class="o">=</span> <span class="n">normalize_yamaha_product_id</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">yamaha_pattern</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">test_case</span> <span class="o">==</span> <span class="n">output</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'Pass'</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'Fail: "{test_case}" is not equal to "{output}'</span><span class="p">)</span>

    

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Pass
Pass
Pass
Pass
Pass
</code></pre></div></div>

<p>Everything passed! Now that we have tested our function and know it works.  Let‚Äôs use it to normalize the IDs in <code class="highlighter-rouge">products</code>. We initialize a <code class="highlighter-rouge">Counter</code> object with <code class="highlighter-rouge">products</code>.  This gives us an object where we can easily get the unique IDs and counts  the various instances each individual ID. Let‚Äôs normalize just the unique IDs.  The ‚ÄòChange‚Äô column is <em>True</em> if the input is different than the output and <em>False</em> if there is no difference.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">products</span><span class="p">)</span>

<span class="n">total_changes</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'No.</span><span class="se">\t</span><span class="s">Original</span><span class="se">\t</span><span class="s">Normalized</span><span class="se">\t</span><span class="s">Change'</span><span class="p">)</span>

<span class="n">ids</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">normalized_product</span> <span class="o">=</span> <span class="n">normalize_yamaha_product_id</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">yamaha_pattern</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">product</span> <span class="o">==</span> <span class="n">normalized_product</span><span class="p">:</span>
        <span class="n">change</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">counter</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">normalized_product</span><span class="p">,</span> <span class="n">change</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">change</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">total_changes</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">counter</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">normalized_product</span><span class="p">,</span> <span class="n">change</span><span class="p">))</span>

<span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">normalized_product</span><span class="p">,</span> <span class="n">change</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'{counter}</span><span class="se">\t</span><span class="s">{product.ljust(10)}</span><span class="se">\t</span><span class="s">{normalized_product.ljust(10)}</span><span class="se">\t</span><span class="s">{change}'</span><span class="p">)</span>  

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>No.	Original	Normalized	Change
1	YAC1607   	YAC-1607  	True
2	YAS - 26  	YAS-26    	True
3	YAS - 480 	YAS-480   	True
4	YAS - 480SY	YAS-480SY 	True
5	YAS 480   	YAS-480   	True
6	YAS 6211  	YAS-6211  	True
7	YAS 662 III	YAS-662III	True
8	YAS-200AD II	YAS-200ADII	True
9	YAS-200ADII	YAS-200ADII	False
</code></pre></div></div>

<p>Feel free to look through the results. It appears that the function is working as intended.</p>

<h3 id="analysis">Analysis</h3>

<p>Let‚Äôs examen how this function changed the data. For comparison we‚Äôll also create a new <code class="highlighter-rouge">Counter</code> with the normalized forms.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">normalized_data</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">normalize_yamaha_product_id</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">yamaha_pattern</span><span class="p">)</span> <span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">products</span><span class="p">])</span>

<span class="n">num_of_products</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">num_of_uniq_products</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">normalized_data</span><span class="p">))</span>

<span class="n">percentage_decrease</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">num_of_products</span> <span class="o">-</span> <span class="n">num_of_uniq_products</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_of_products</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'{num_of_products} unique IDs was reduced to {num_of_uniq_products} IDs'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'That</span><span class="se">\'</span><span class="s">s a decrease of {percentage_decrease}</span><span class="si">%</span><span class="s">!'</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>260 unique IDs was reduced to 173 IDs
That's a decrease of 33.46%!
</code></pre></div></div>

<p>We can make a table comparing the top 10 Product Numbers before normalization and after normalization.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">heading</span> <span class="o">=</span> <span class="s">'No.'</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="s">'Old ID'</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s">'Cnt'</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="s">'New ID'</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s">'Cnt'</span>
<span class="k">print</span><span class="p">(</span><span class="n">heading</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'-'</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>

<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">normalized_data</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">10</span><span class="p">)):</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">old_id</span>    <span class="o">=</span> <span class="n">old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">old_count</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">old</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">new_id</span>    <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">new_count</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'{ str(counter).ljust(5) }{ old_id }{ old_count }{ new_id }{ new_count }'</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>No.  Old ID    Cnt  New ID    Cnt
------------------------------
1    YBS-52    20   YBS-52    31
2    YBB-105WC 16   YBB-105WC 24
3    YEP-321   16   YEP-201   21
4    YAS-26    12   YEP-321   20
5    YCL-221   11   YAS-26    17
6    YTS-480   11   YTS-480   17
7    YBS52     10   YCL-221   15
8    YEP-201   10   YCL-255   15
9    YCL-255   9    YAS-480   13
10   YHR-567   9    YCL-221II 12
</code></pre></div></div>

<p>From the table we can see that the YBS-52 is still the most common item requested, and that ‚ÄòYBS52‚Äô has been removed from the list.  As a few other items such as the YCL-255 and YHR-576 were removed from the Top 10, this new Top 10 list provides more accurate insights.</p>

<p>Now let‚Äôs look at the percentage increases of the Top 10 items. To get the percentage change:</p>

<script type="math/tex; mode=display">\frac{\text{new number} - \text{old number}}{\text{old number}} \times{100}</script>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'Product ID'</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span> <span class="s">'Percentage Change'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'-'</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
<span class="k">for</span> <span class="n">product</span><span class="p">,</span> <span class="n">new_count</span> <span class="ow">in</span> <span class="n">normalized_data</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">old_count</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">product</span><span class="p">]</span>
    <span class="n">percentage_increase</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">new_count</span> <span class="o">-</span> <span class="n">old_count</span><span class="p">)</span> <span class="o">/</span> <span class="n">old_count</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'{product.ljust(12)}{percentage_increase}</span><span class="si">%</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Product ID  Percentage Change
------------------------------
YBS-52      55.0%
YBB-105WC   50.0%
YEP-201     110.0%
YEP-321     25.0%
YAS-26      41.67%
YTS-480     54.55%
YCL-221     36.36%
YCL-255     66.67%
YAS-480     62.5%
YCL-221II   71.43%
</code></pre></div></div>

<p>We can see that the new top products all received significant count increases when we started counting more accurately.</p>

<h3 id="conclusion">Conclusion</h3>

<p>In this post we saw how we could extract substrings using regular expression named groups, and how we could use them to clean up messy data. The more accurate our</p>
:ET